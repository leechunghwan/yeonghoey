#+TITLE: Linux

* Table of Contents                                                :TOC_1_gh:
 - [[#the-art-of-command-line][The Art of Command Line]]
 - [[#history-expasion][History Expasion]]
 - [[#mounting-a-volume][Mounting a Volume]]
 - [[#prompt-a-user-for-yesno][Prompt a user for yes/no]]
 - [[#apt][apt]]
 - [[#case][case]]
 - [[#grep][grep]]
 - [[#here-document][here-document]]
 - [[#pgrep][pgrep]]
 - [[#set][set]]
 - [[#xargs][xargs]]

* The Art of Command Line
- https://github.com/jlevy/the-art-of-command-line

** set best practice
#+BEGIN_SRC shell
  set -euo pipefail
  trap "echo 'error: Script failed: see failed command above'" ERR
#+END_SRC
- ~-e~ for errors
- ~-u~ for preventing unset
- ~-o pipefail~ for errors within pipes

** subshell
#+BEGIN_SRC shell
  # do something in current dir
  (cd /some/other/dir && other-command)
  # continue in original dir
#+END_SRC

** command out like as a file
#+BEGIN_SRC shell
  diff /etc/hosts <(ssh somehost cat /etc/hosts)
#+END_SRC

** prevents partially downloaded scripts from executing
#+BEGIN_SRC shell
  {
      # Your code here
  }
#+END_SRC

** python simple web server for sharing files
#+BEGIN_SRC shell
  python -m SimpleHTTPServer 7777
  python3 -m http.server 7777
#+END_SRC

** One-liners
#+BEGIN_SRC shell
  cat a b | sort | uniq > c        # c is a union b
  cat a b | sort | uniq -d > c     # c is a intersect b
  cat a b b | sort | uniq -u > c   # c is set difference a - b

  grep . * t   # overview for contents of current directory
  head -100 *  # same as above, with only first 100 lines

  # sum of all numbers in the third column
  awk '{ x += $3 } END { print x }' myfile
#+END_SRC

* History Expasion
#+BEGIN_SRC shell
  $ history
  1 tar cvf etc.tar /etc/
  2 cp /etc/passwd /backup
  3 ps -ef | grep http
  4 service sshd restart
  5 /usr/local/apache2/bin/apachectl restart

  $ !4  # 4
  service sshd restart

  $ !-2  # 2 commands back
  service sshd restart

  $ !!   # last (1 command back)
  $ !-1

  $ !ps  # command that starts with 'ps'
  ps -ef | grep http

  $ !?apache  # command that contains 'apache'
  /usr/local/apache2/bin/apachectl restart


  $ ls /etc/cron.daily/logrotate

  $ ^ls^cat^  # replace 'ls' with 'cat'
  cat /etc/cron.daily/logrotate

  $ cp /etc/passwd /backup

  $ ls -l !cp:^  # first argument
  ls -l /etc/passwd

  $ cp /etc/passwd /backup

  $ ls -l !cp:$  # last argument
  ls -l /backup

  $ ls -l !!:$  # last argument of last command
  $ ls -l !$    # equivalent to above

  $ ls -l !!:2  # second
  $ ls -l !!:*  # all

  $ !!:s/ls -l/cat/  # substitution

  $ cp /etc/password /backup/password.bak
  $ !!:gs/password/passwd/  # global substitution
  cp /etc/passwd /backup/passwd.bak

  $ ls -l !!:$:p  # print without executing it
#+END_SRC
- http://www.thegeekstuff.com/2011/08/bash-history-expansion

* Mounting a Volume
- http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html

** Basic Workflow
#+BEGIN_SRC shell
  # view your available disk devices and their mount points 
  $ lsblk
  NAME  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
  xvdf  202:80   0  100G  0 disk
  xvda1 202:1    0    8G  0 disk /
#+END_SRC

#+BEGIN_SRC shell
  $ sudo file -s /dev/xvda1
  /dev/xvda1: Linux rev 1.0 ext4 filesystem data, UUID=1701d228-e1bd-4094-a14c-8c64d6819362, ...

  # no file system
  $ sudo file -s /dev/xvdf
  /dev/xvdf: data
#+END_SRC

#+BEGIN_SRC shell
  $ sudo mkfs -t ext4 /dev/xvdf

  $ sudo mkdir /my/path
  $ sudo mount /dev/xvdf /my/path
#+END_SRC

#+BEGIN_SRC shell
  # Mount the volume permanently
  $ sudo cp /etc/fstab /etc/fstab.orig  # backup

  # /etc/fstab : columns are separated with '\t'
  # ------------------------------------------------------------------------------
  # Use UUID because /dev/xvdf may change
  # - check UUID from the output of file -s /dev/xvdf
  # SEE: $ man fstab
  # - 0 stands for (not dumping, default)
  # - 2 stands for (other than root volume)
  /dev/xvda1  (...)
  UUID=de9a1ccd-a2dd-44f1-8be8-2d4275cb85a3  /my/path  ext4  defaults,nofail  0  2
  # ------------------------------------------------------------------------------

  # mount with /etc/fstab manually
  $ sudo mount -a
#+END_SRC

** lost+found
- http://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix

#+BEGIN_QUOTE
The thing is, the file had a name and location once, but that information is no longer available.
So fsck deposits the file in a specific directory, called lost+found
#+END_QUOTE

#+BEGIN_QUOTE
Files that appear in lost+found are typically files that were already unlinked (i.e. their name had been erased)
but still opened by some process (so the data wasn't erased yet)when the system halted suddenly (kernel panic or power failure).
If that's all that happened, these files were slated for deletion anyway, you don't need to care about them.
#+END_QUOTE

#+BEGIN_QUOTE
On many filesystems, the lost+found directory is a bit special
because it preallocates a bit of space for fsck to deposit files there. (...)
If you accidentally delete lost+found, don't re-create it with mkdir, use mklost+found if available.
#+END_QUOTE

* Prompt a user for yes/no
#+BEGIN_SRC shell
  read -p "Are you sure you want to continue? <y/N> " prompt
  if [[ "$prompt" =~ [yY](es)* ]]
  then
  fi
#+END_SRC
- http://stackoverflow.com/questions/3231804/in-bash-how-to-add-are-you-sure-y-n-to-any-command-or-alias/3231821#3231821
- http://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script


* apt
**  Install java8
- http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/
 
#+BEGIN_SRC shell
  sudo add-apt-repository ppa:webupd8team/java
  sudo apt-get update
  sudo apt-get install oracle-java8-installer

  java -version
  sudo apt-get install oracle-java8-set-default

  sudo update-alternatives --config java
#+END_SRC

** When 'apt-get update' fails

- Check files in:
  #+BEGIN_EXAMPLE
    /etc/apt/sources.list
    /etc/apt/sources.list.d/*.list
  #+END_EXAMPLE

* case
#+BEGIN_SRC shell
  case "$1" in
    start)
      start
      ;;
    stop)
      stop
      ;;
    ,*)
      echo $"Usage: $0 {start|stop}"
      exit 1
      ;;
  esac
#+END_SRC
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html

* grep
#+BEGIN_SRC shell
  $ echo hello world | grep hello
  hello world

  # --only-matching
  $ echo hello world | grep -o hello
  hello
#+END_SRC

* here-document
- https://en.wikipedia.org/wiki/Here_document

#+BEGIN_SRC shell
  tr a-z A-Z << END_TEXT
  one two three
  four five six
  END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  ONE TWO THREE
  FOUR FIVE SIX
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Ignore leading tabs
  tr a-z A-Z <<- END_TEXT
           one two three
           four five six
           END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  (Same as above)
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Disable string interpolation
  cat << 'EOF'
  \$ Working dir "$PWD" `pwd`
  EOF
#+END_SRC
#+BEGIN_EXAMPLE
  \$ Working dir "$PWD" `pwd`
#+END_EXAMPLE

* pgrep

- Same usages, but ~pkill~ will kill match processes
#+BEGIN_SRC shell
  $ pgrep pytho
  $ pgrep -f script.py  # match against full arugment lists
  $ pgrep -l pytho      # Print pids along with their process names
  $ pgrep -f -l .py     # Print pids along with their full argument lists
  $ pgrep -x python     # requires exact match, substr is default
  $ pkill -9 pytho      # You can also specify singal
#+END_SRC

* set
- http://ss64.com/bash/set.html
 
#+BEGIN_SRC shell
  set -e  # Exit immediately when a command fails
  set -x  # Print a trace of simple commands
#+END_SRC

* xargs
#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs echo

  # equivalent to:
  echo 1 2 3 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 1 echo

  # equivalent to:
  echo 1
  echo 2
  echo 3
  echo 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 2 echo

  # equivalent to:
  echo 1 2
  echo 3 4
#+END_SRC

#+BEGIN_SRC shell
  # Specify replace-str
  $ echo 1 2 3 4 | xargs -I {} echo '{} numbers'

  # equivalent to
  echo '1 2 3 4 numbers'
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -p echo   # Prompt
  $ echo 1,2,3,4 | xargs -d, echo  # Set delimiter to ','

  # Use null character as input terminator, useful when input contains white space.
  # For example, 'find -print0' supports this
  $ echo 1 2 3 4 | xargs -0 echo
#+END_SRC

- http://www.thegeekstuff.com/2013/12/xargs-examples
- http://www.unixmantra.com/2013/12/xargs-all-in-one-tutorial-guide.html
- https://www.cyberciti.biz/faq/linux-unix-bsd-xargs-construct-argument-lists-utility/
