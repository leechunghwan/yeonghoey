#+TITLE: Shell

* Table of Contents                                                :TOC_1_gh:
 - [[#the-art-of-command-line][The Art of Command Line]]
 - [[#prompt-a-user-for-yesno][Prompt a user for yes/no]]
 - [[#history-expasion][History Expasion]]
 - [[#mounting-a-volume][Mounting a Volume]]
 - [[#glob-dotfiles][Glob dotfiles]]
 - [[#apt][apt]]
 - [[#case][case]]
 - [[#grep][grep]]
 - [[#here-document][here-document]]
 - [[#lsof][lsof]]
 - [[#pgrep][pgrep]]
 - [[#set][set]]
 - [[#sort][sort]]
 - [[#tar][tar]]
 - [[#tee][tee]]
 - [[#xargs][xargs]]

* The Art of Command Line
- https://github.com/jlevy/the-art-of-command-line

** set best practice
#+BEGIN_SRC shell
  set -euo pipefail
  trap "echo 'error: Script failed: see failed command above'" ERR
#+END_SRC
- ~-e~ for errors
- ~-u~ for preventing unset
- ~-o pipefail~ for errors within pipes

** subshell
#+BEGIN_SRC shell
  # do something in current dir
  (cd /some/other/dir && other-command)
  # continue in original dir
#+END_SRC

** command out like as a file
#+BEGIN_SRC shell
  diff /etc/hosts <(ssh somehost cat /etc/hosts)
#+END_SRC

** prevents partially downloaded scripts from executing
#+BEGIN_SRC shell
  {
      # Your code here
  }
#+END_SRC

** python simple web server for sharing files
#+BEGIN_SRC shell
  python -m SimpleHTTPServer 7777
  python3 -m http.server 7777
#+END_SRC

** One-liners
#+BEGIN_SRC shell
  cat a b | sort | uniq > c        # c is a union b
  cat a b | sort | uniq -d > c     # c is a intersect b
  cat a b b | sort | uniq -u > c   # c is set difference a - b

  grep . *     # overview for contents of current directory
  head -100 *  # same as above, with only first 100 lines

  # sum of all numbers in the third column
  awk '{ x += $3 } END { print x }' myfile
#+END_SRC

* Prompt a user for yes/no
- http://stackoverflow.com/questions/3231804/in-bash-how-to-add-are-you-sure-y-n-to-any-command-or-alias/3231821#3231821
- http://stackoverflow.com/questions/226703/how-do-i-prompt-for-yes-no-cancel-input-in-a-linux-shell-script
 
#+BEGIN_SRC shell
  read -p "Are you sure you want to continue? <y/N> " prompt
  if [[ "$prompt" =~ [yY](es)* ]]
  then
  fi
#+END_SRC

* History Expasion
- http://www.thegeekstuff.com/2011/08/bash-history-expansion

#+BEGIN_SRC shell
  $ history
  1 tar cvf etc.tar /etc/
  2 cp /etc/passwd /backup
  3 ps -ef | grep http
  4 service sshd restart
  5 /usr/local/apache2/bin/apachectl restart

  $ !4  # 4
  service sshd restart

  $ !-2  # 2 commands back
  service sshd restart

  $ !!   # last (1 command back)
  $ !-1

  $ !ps  # command that starts with 'ps'
  ps -ef | grep http

  $ !?apache  # command that contains 'apache'
  /usr/local/apache2/bin/apachectl restart


  $ ls /etc/cron.daily/logrotate

  $ ^ls^cat^  # replace 'ls' with 'cat'
  cat /etc/cron.daily/logrotate

  $ cp /etc/passwd /backup

  $ ls -l !cp:^  # first argument
  ls -l /etc/passwd

  $ cp /etc/passwd /backup

  $ ls -l !cp:$  # last argument
  ls -l /backup

  $ ls -l !!:$  # last argument of last command
  $ ls -l !$    # equivalent to above

  $ ls -l !!:2  # second
  $ ls -l !!:*  # all

  $ !!:s/ls -l/cat/  # substitution

  $ cp /etc/password /backup/password.bak
  $ !!:gs/password/passwd/  # global substitution
  cp /etc/passwd /backup/passwd.bak

  $ ls -l !!:$:p  # print without executing it
#+END_SRC

* Mounting a Volume
- http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/ebs-using-volumes.html

** Basic Workflow
#+BEGIN_SRC shell
  # view your available disk devices and their mount points 
  $ lsblk
  NAME  MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
  xvdf  202:80   0  100G  0 disk
  xvda1 202:1    0    8G  0 disk /
#+END_SRC

#+BEGIN_SRC shell
  $ sudo file -s /dev/xvda1
  /dev/xvda1: Linux rev 1.0 ext4 filesystem data, UUID=1701d228-e1bd-4094-a14c-8c64d6819362, ...

  # no file system
  $ sudo file -s /dev/xvdf
  /dev/xvdf: data
#+END_SRC

#+BEGIN_SRC shell
  $ sudo mkfs -t ext4 /dev/xvdf

  $ sudo mkdir /my/path
  $ sudo mount /dev/xvdf /my/path
#+END_SRC

#+BEGIN_SRC shell
  # Mount the volume permanently
  $ sudo cp /etc/fstab /etc/fstab.orig  # backup

  # /etc/fstab : columns are separated with '\t'
  # ------------------------------------------------------------------------------
  # Use UUID because /dev/xvdf may change
  # - check UUID from the output of file -s /dev/xvdf
  # SEE: $ man fstab
  # - 0 stands for (not dumping, default)
  # - 2 stands for (other than root volume)
  /dev/xvda1  (...)
  UUID=de9a1ccd-a2dd-44f1-8be8-2d4275cb85a3  /my/path  ext4  defaults,nofail  0  2
  # ------------------------------------------------------------------------------

  # mount with /etc/fstab manually
  $ sudo mount -a
#+END_SRC

** lost+found
- http://unix.stackexchange.com/questions/18154/what-is-the-purpose-of-the-lostfound-folder-in-linux-and-unix

#+BEGIN_QUOTE
The thing is, the file had a name and location once, but that information is no longer available.
So fsck deposits the file in a specific directory, called lost+found
#+END_QUOTE

#+BEGIN_QUOTE
Files that appear in lost+found are typically files that were already unlinked (i.e. their name had been erased)
but still opened by some process (so the data wasn't erased yet)when the system halted suddenly (kernel panic or power failure).
If that's all that happened, these files were slated for deletion anyway, you don't need to care about them.
#+END_QUOTE

#+BEGIN_QUOTE
On many filesystems, the lost+found directory is a bit special
because it preallocates a bit of space for fsck to deposit files there. (...)
If you accidentally delete lost+found, don't re-create it with mkdir, use mklost+found if available.
#+END_QUOTE

* Glob dotfiles
- http://stackoverflow.com/questions/20895502/bash-asterisk-omits-files-that-start-with
- http://unix.stackexchange.com/questions/89749/cp-hidden-files-with-glob-patterns

You can't just match dotfiles(whose names start with ~.~) with the wildcard(~*~).
There are some workarounds:
#+BEGIN_SRC shell
  for item in .* *; do echo "$item"; done  # simplest

  # for bash (shopt is bash specific)
  shopt -s dotglob  # set dotglob
  echo *
  shopt -u dotglob  # unset dotglob

  # for zsh (glob qualifier, GLOB_DOTS)
  $ cp foo/*(D) .
#+END_SRC

* apt
**  Install java8
- http://tecadmin.net/install-oracle-java-8-jdk-8-ubuntu-via-ppa/
 
#+BEGIN_SRC shell
  sudo add-apt-repository ppa:webupd8team/java
  sudo apt-get update
  sudo apt-get install oracle-java8-installer

  java -version
  sudo apt-get install oracle-java8-set-default

  sudo update-alternatives --config java
#+END_SRC

** When 'apt-get update' fails

- Check files in:
  #+BEGIN_EXAMPLE
    /etc/apt/sources.list
    /etc/apt/sources.list.d/*.list
  #+END_EXAMPLE

* case
- http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_07_03.html

#+BEGIN_SRC shell
  case "$1" in
    start)
      start
      ;;
    stop)
      stop
      ;;
    ,*)
      echo $"Usage: $0 {start|stop}"
      exit 1
      ;;
  esac
#+END_SRC

* grep
#+BEGIN_SRC shell
  $ echo hello world | grep hello
  hello world

  # --only-matching
  $ echo hello world | grep -o hello
  hello
#+END_SRC

* here-document
- https://en.wikipedia.org/wiki/Here_document

#+BEGIN_SRC shell
  tr a-z A-Z << END_TEXT
  one two three
  four five six
  END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  ONE TWO THREE
  FOUR FIVE SIX
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Ignore leading tabs
  tr a-z A-Z <<- END_TEXT
           one two three
           four five six
           END_TEXT
#+END_SRC
#+BEGIN_EXAMPLE
  (Same as above)
#+END_EXAMPLE


#+BEGIN_SRC shell
  # Disable string interpolation
  cat << 'EOF'
  \$ Working dir "$PWD" `pwd`
  EOF
#+END_SRC
#+BEGIN_EXAMPLE
  \$ Working dir "$PWD" `pwd`
#+END_EXAMPLE

* lsof
#+BEGIN_SRC shell
  # numeric ip(-n) and port(-P)
  $ lsof -n -P | less
#+END_SRC

* pgrep
- Same usages, but ~pkill~ will kill match processes

#+BEGIN_SRC shell
  $ pgrep pytho
  $ pgrep -f script.py  # match against full arugment lists
  $ pgrep -l pytho      # Print pids along with their process names
  $ pgrep -f -l .py     # Print pids along with their full argument lists
  $ pgrep -x python     # requires exact match, substr is default
  $ pkill -9 pytho      # You can also specify singal
#+END_SRC

* set
- http://ss64.com/bash/set.html
 
#+BEGIN_SRC shell
  set -e  # Exit immediately when a command fails
  set -x  # Print a trace of simple commands
#+END_SRC

* sort
- http://ss64.com/bash/sort.html
- http://www.skorks.com/2010/05/sort-files-like-a-master-with-the-linux-sort-command-bash/

#+BEGIN_SRC shell
  sort -nr numbers.txt # descending numeric order
  sort -k3 output.txt  # key3, omitting the first and second fields.
  sort -f names.txt    # ignore case
  sort -s names.txt    # stable sort
  sort -u names.txt    # unique
  sort -t: /etc/passwd # use ':' as the field delimiter
#+END_SRC

#+BEGIN_SRC shell
  # Sort by column2 and then column4, numerically, delimited by '.'
  # while -k2  only specifies starting point is column2
  # -k2,2  specifies both starting, and ending point. which means exact column2.

  $ cat ips.txt | sort -t. -k 2,2n -k 4,4n
  127.0.0.3
  127.0.0.6
  127.0.0.12
  192.168.0.1
  192.168.0.5
  192.168.0.25
#+END_SRC

* tar
- http://www.tecmint.com/18-tar-command-examples-in-linux/
- http://askubuntu.com/questions/122141/whats-the-difference-between-tar-gz-and-gz-or-tar-7z-and-7z
 
| flag      | mnemonic         |
|-----------+------------------|
| ~-c~      | create           |
| ~-x~      | extract          |
| ~-t~      | list             |
| ~-v~      | verbose          |
| ~-C DIR~  | change directory |
| ~-f FILE~ | target file      |

-----
#+BEGIN_SRC shell
  $ cd /tmp
  $ tree target
#+END_SRC
#+BEGIN_EXAMPLE
  target
  ├── a.txt
  └── path
      └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ tar -cvf target1.tar /tmp/target
#+END_SRC
#+BEGIN_EXAMPLE
  tar: Removing leading '/' from member names
  a tmp/target
  a tmp/target/a.txt
  a tmp/target/path
  a tmp/target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ tar -xvf target1.tar
  $ tree tmp
#+END_SRC
#+BEGIN_EXAMPLE
  tmp
  └── target
      ├── a.txt
      └── path
          └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Change directory
  $ tar -C /tmp/target -cvf target2.tar .
#+END_SRC
#+BEGIN_EXAMPLE
  a .
  a ./a.txt
  a ./path
  a ./path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  $ mkdir out
  $ tar -C out -xvf target2.tar
  $ tree out
#+END_SRC
#+BEGIN_EXAMPLE
  out
  ├── a.txt
  └── path
      └── b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Exclude
  $ tar -cvf target3.tar --exclude a.txt target
#+END_SRC
#+BEGIN_EXAMPLE
  a target
  a target/path
  a target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
#+BEGIN_SRC shell
  # Compression
  $ tar -cvzf target.tar.gz target
#+END_SRC
#+BEGIN_EXAMPLE
  a target
  a target/a.txt
  a target/path
  a target/path/b.txt
#+END_EXAMPLE
----- 
#+BEGIN_SRC shell
  # Don't need any option for extracting compressed tar
  $ tar -xvf target.tar.gz
#+END_SRC
#+BEGIN_EXAMPLE
  x target/
  x target/a.txt
  x target/path/
  x target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # List
  $ tar -tvf target.tar.gz
#+END_SRC
#+BEGIN_EXAMPLE
  drwxr-xr-x  0 hoey   staff       0 Jan 30 10:26 target/
  -rw-r--r--  0 hoey   staff       0 Jan 30 10:23 target/a.txt
  drwxr-xr-x  0 hoey   staff       0 Jan 30 10:26 target/path/
  -rw-r--r--  0 hoey   staff       0 Jan 30 10:23 target/path/b.txt
#+END_EXAMPLE
-----
#+BEGIN_SRC shell
  # Untar a single file
  $ tar -xvf target.tar.gz target/a.txt
#+END_SRC
#+BEGIN_EXAMPLE
  x target/a.txt
#+END_EXAMPLE

* tee
- https://shapeshed.com/unix-tee/
 
#+BEGIN_SRC shell
  $ echo 'foo' | tee foo.txt
  foo
  $ cat foo.txt
  foo

#+END_SRC

#+BEGIN_SRC shell
  $ cat foo.txt
  foo
  $ echo 'bar' | tee -a foo.txt  # append
  bar
  $ cat foo.txt
  foo
  bar
#+END_SRC

#+BEGIN_SRC shell
  # Redirecting stdout is not affected by 'sudo'
  $ echo 'foo' >> file
  zsh: permission denied: file

  # 'tee' can be used to work around this  
  $ echo "foo" | sudo tee -a file
#+END_SRC

* xargs
- http://www.thegeekstuff.com/2013/12/xargs-examples
- http://www.unixmantra.com/2013/12/xargs-all-in-one-tutorial-guide.html
- https://www.cyberciti.biz/faq/linux-unix-bsd-xargs-construct-argument-lists-utility/

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs echo

  # equivalent to:
  echo 1 2 3 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 1 echo

  # equivalent to:
  echo 1
  echo 2
  echo 3
  echo 4
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -n 2 echo

  # equivalent to:
  echo 1 2
  echo 3 4
#+END_SRC

#+BEGIN_SRC shell
  # Specify replace-str
  $ echo 1 2 3 4 | xargs -I {} echo '{} numbers'

  # equivalent to
  echo '1 2 3 4 numbers'
#+END_SRC

#+BEGIN_SRC shell
  $ echo 1 2 3 4 | xargs -p echo   # Prompt
  $ echo 1,2,3,4 | xargs -d, echo  # Set delimiter to ','

  # Use null character as input terminator, useful when input contains white space.
  # For example, 'find -print0' supports this
  $ echo 1 2 3 4 | xargs -0 echo

  # Delete files whose names contain 'conflicted'
  $ find . -name '*conflicted*' -print0 | xargs -0 rm
#+END_SRC
